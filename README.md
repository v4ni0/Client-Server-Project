# Проект: Проект по Мрежово Програмиране

## Описание на Проекта
Проектът реализира алгоритъма Merge Sort, интегриран с клиент-сървър архитектура. Включени са три различни имплементации на сървъра: **select**, **multithreaded** и **simple** (обработва само един клиент). Идеята е клиентът да подаде масив от цели числа и допълнителни данни, а сървърът да върне сортирания масив като съобщение.

## 1. Имплементация на Merge Sort
В класа `MergeSort` е представена имплементация на Merge Sort в пакета mergesort, която може да приема различни обекти, които могат да бъдат сравнени (наследяват `Comparable`). Конструкторът приема аргументи: масив, брой на нишки и минимален размер на масив, за да бъде сортиран паралелно (понеже ако използваме постоянно много нишки, продуктивността пада).  

За паралелизацията е използван `ForkJoinPool`, тъй като се използват рекурсивни подзадачи и thread pool с фиксиран размер няма да свърши работа. Затова е създаден класа `Task`, който наследява `RecursiveAction`. Чрез метода `run()` се изпълнява сортирането, като сортирането е in-place и не се връща нов масив. Включени са и няколко теста за коректността на алгоритъма.

## 2. Time Comparison
Този клас сравнява няколко пъти времето, отнело за сортиране при различни аргументи на `MergeSort` и различен размер на масива. Създава се файл `merge_sort_times.txt`, който изписва времето, отнело за изпълнение на паралелен и непаралелен Merge Sort. От там можем да видим, че при подходяща граница на елементите за сортиране и размер на масива (който би бил малко по-голям), паралелизацията съкращава времето за изпълнение значително.

## 3. Client
Имаме една имплементация на Client, която работи за всички сървъри. Приемаме, че нашият сървър винаги ще използва порт = 10,000. Клиентът се опитва да установи връзка и след като установи такава, изпраща брой нишки, граница за паралелизация и Integer масив в следния формат:  
`брой_нишки;размер_за_паралелизация;масив`, където масивът трябва да се подаде по следния начин: `number1,number2,number3,number4`, където `array = [number1,number2,number3,number4]` е масивът, който искаме да сортираме.  

Сървърът връща като String сортирания масив, но включва и `[]`, затова използваме функцията `parseArray`. При вход `exit` от конзолата, работата на `main` функцията приключва и съответно сървърът получава `null`.  

`Socket socket = new Socket("localhost", SERVER_PORT);` създава връзка със сървъра на порт `SERVER_PORT`, а чрез `socket.getInputStream()` взимаме входния поток за клиента и обработваме получените съобщения.

## 4. Simple Server
В пакета `servers.simple` Simple Server представлява еднонишкова (single-threaded) client–server имплементация, която обслужва само един клиент в даден момент. Сървърът слуша на фиксиран порт 10,000, приема входни данни от клиент, сортира подадения масив чрез паралелния Merge Sort и връща сортирания масив обратно към клиента като текстово съобщение.  

Стартирането на сървъра се извършва чрез метода `start()`, който създава `ServerSocket` на порт 10,000 и изчаква входяща клиентска връзка. След като клиентът се свърже, сървърът обработва всички получени съобщения последователно.  

Комуникацията със клиента се осъществява чрез входен поток `BufferedReader` и изходен поток `PrintWriter`. `BufferedReader` чете съобщенията от клиента ред по ред, като всяко съобщение трябва да бъде в следния формат: `брой нишки;минимален размер за паралелизация;масив`. След получаване на съобщението, то се разделя на три части, които представляват аргументите за конструктора на класа `MergeSort`.  

Сървърът използва помощни методи за парсване на всяка от трите части. Масивът се преобразува от текстов формат към `Integer` масив. Ако форматът на входните данни е невалиден, сървърът връща съобщение за грешка към клиента.  

След успешно парсване на входните данни се създава инстанция на `MergeSort`, като се подават масивът, броят нишки и минималният размер за паралелизация, и се сортира чрез метода `run()`.  

След приключване на сортирането, сървърът изпраща обратно към клиента сортирания масив, преобразуван в String формат чрез `Arrays.toString()`.

## 5. Multithreaded Server
В пакета `servers.multithreaded` е реализирана многнишкова (multithreaded) client–server имплементация, която позволява едновременното обслужване на множество клиенти. За разлика от Simple Server, който може да работи само с един клиент, тук всеки клиент се обработва в отделна нишка.  

Сървърът слуша на фиксиран порт 10,000 и използва `ExecutorService` с фиксиран брой нишки. В настоящата имплементация се използва thread pool с максимален размер от 5 нишки, което позволява до пет клиента да бъдат обслужвани едновременно (това може лесно да се промени).  

При стартиране на сървъра се създава `ServerSocket`, който непрекъснато изчаква входящи клиентски връзки. За всяка нова връзка се създава задача чрез ламбда израз, която се подава към thread pool-а чрез `ExecutorService`. Тази задача извиква метода `handleClient`, който отговаря за цялата комуникация с конкретния клиент.  

Комуникацията с клиента е по същия начин както със Simple Server, както и парсването и изпълнението на сортирането.

## 6. Select Server
В пакета `servers.select` е реализирана сървърна имплементация, базирана на Java NIO и механизма `Selector`, която позволява една нишка да работи с няколко клиента едновременно.  

Сървърът използва `ServerSocketChannel`, конфигуриран в неблокиращ режим, и регистрира каналите към `Selector`, който следи за събития като нови входящи връзки и налични данни за четене. Проверката за това става със `selector.select()`. Ако има, взимаме итератора на ключовете и проверяваме всеки канал дали е `isReadable` или `isAcceptable`. Ако има нови заявки (за четене или за установяване на връзка) използваме съответно методите registerClient и readFromClient. 

При получаване на съобщение от клиент, сървърът прочита данните чрез `ByteBuffer`, парсва входните параметри (брой нишки, минимален размер за паралелизация и масив) и извършва сортиране чрез класа `MergeSort`. След приключване на сортирането резултатът се изпраща обратно към клиента във String формат(чрез метода sendToClient).

## Структура на пакетите:
```
src
├── main
│   └── java
│       ├── client 
│       │   └── Client
│       ├── mergesort 
│       │   ├── MergeSort 
│       │   └── Task 
│       |   └── TimeComparison 
│       └── servers 
│           ├── multithreaded 
│           │   └── Server 
│           ├── select 
│           │   └── Server 
│           └── simple 
│               └── Server 
```

# Начин на изпълнение

1. Изпълняване на main-а на един от сървърите (SimpleServer, MultithreadedServer или SelectServer, в зависимост от избраната имплементация).
2. Изпълняване на main-а на клиента.
3. Подаване на входни данни в конзолата на клиента в следния формат: `брой_нишки;размер_за_паралелизация;масив`, където масивът е във вида `number1,number2,number3,...`.
4. Сървърът ще обработи данните, ще сортира масива с помощта на паралелния Merge Sort и ще върне сортирания масив като отговор.
5. За да спрете клиента, въведете `exit` в конзолата.
## Пример за изпълнение
- **Вход в клиента:** `4;100;5,3,8,1,9,2,7,4,6`
- **Очаквано съобщение от сървъра към клиента:** `[1, 2, 3, 4, 5, 6, 7, 8, 9]` .
